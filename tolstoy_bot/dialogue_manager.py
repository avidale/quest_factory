# -*- coding: utf-8 -*-
"""
This file contains the main class for dialogue management.
This class is messenger-agnostic, ang could be reused with VK, WhatsApp, etc.
"""
import pandas as pd
import numpy as np
# todo: add logging of all the input and output messages within the bot

# todo: большой вопрос, как обрабатывать паузы!
# todo: introduce specific MESSAGE and RESPONSE objects, messenger-agnostic.
# this way, main.py does not have to parse reactions.


class StupidLinearDialogue:
    """ Handler of primitive sequential dialogues.
    """
    script = None   # dataframe with the whole scenario
    config = None   # dict with additional setup data
    position = 0    # index of current state of the bot (its last action)
    default_negative_response = None
    default_pause = 5
    count = 0
    location_matcher = None
    
    def __init__(self, script):
        """ 
        Parameters:
        script: pd.DataFrame keyed by ['action', 'reaction',
            'tag', 'next_tags', 'negative_reaction']
        """
        self.script = script
        self.reset()
    
    def reset(self):
        """ Roll back the bot state """
        self.position = 0  # последнее завершённое действие
        self.count = self.script.shape[0]
        # parse next positions - they are lists of indices
        # by default, next position is next index (or the first index, for the last row).
        self.script['candidate_positions'] = [[i] for i in list(range(1, self.count)) + [0]]
        if 'next_tags' in self.script and 'tag' in self.script:
            tag2index = self.script.tag.dropna().astype(str).reset_index().set_index('tag')['index'].to_dict()
            candidates = self.script.next_tags.dropna().apply(lambda x: [tag2index[t] for t in x.split('|')])
            self.script['candidate_positions'].update(candidates)
        # fill empty actions and reactions
        for c in ['action', 'reaction']:
            self.script[c] = self.script[c].fillna('').astype(str)

    def next(self, message):
        """ Move along the strictly linear dialogue, independently of user actions.
        """
        if self.position >= self.count:
            self.reset()
            return "Сценарий завершён. Начинаю заново. Таково колесо сансары."
        response = self.script.loc[self.position, 'reaction']
        self.position += 1
        return response
    
    def react(self, action):
        """ Read action, reset state, and return response in a text form.
            action: a raw Telebot message from user, or an event generated by timer.
        """
        response = ''
        for candidate_position in self.script.loc[self.position, 'candidate_positions']:
            if self.is_valid_action(self.script.loc[candidate_position, 'action'], action):
                response = self.script.loc[candidate_position, 'reaction']
                self.position = candidate_position
                break
        if response == '':
            response = self.get_negative_response(self.position)
        return response
    
    def get_negative_response(self, position):
        # by default, repeat previous message
        specific = self.script.loc[0, 'negative_reaction']
        if self.is_valid_string(specific):
            return specific
        elif self.is_valid_string(self.default_negative_response):
            return self.default_negative_response
        return self.script.loc[self.position, 'reaction']
    
    def is_valid_action(self, expected, real):
        if expected.startswith('/'):
            # parse Telegram commands
            return True
        elif expected.startswith('['):
            # todo: allow multiple commands or mix of commands and words
            # parse specific commands
            if expected in {'[anytext]', '[initial]'}:
                return True
            elif expected.startswith('[pause'):
                # todo: parse pause
                # this branch is visited if the user sent something during the pause.
                # it is also visited if the bot has activated itself after the pause.
                # the question is, how to make it activate itself, if next action is pause?
                # another question is how to check, if user writes first, that the pause must go on
                return True
            elif expected.startswith('[location'):
                if self.location_matcher is None:
                    # не могу заматчить локацию, так что возвращаю True
                    return True
                # todo: parse location
        else:
            # check if input equals one of pattern words
            texts = expected.split('|')
            return real.text in texts

    def is_valid_string(self, s):
        return type(s) is str and len(s) > 0

    def check_pause(self):
        #todo: if next expected action is [pause|t] or [pause], return t or self.default_pause
        return None
